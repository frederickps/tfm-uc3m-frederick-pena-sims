---
title: "Master Thesis - Fetching and processing Data"
author: "Frederick Pena Sims"
format: html
editor: visual
---

## Library

```{r}
# |echo: false

library(odbc)
library(RODBC)
library(tidyverse)
library(readxl)
```

## Getting municipal spending data

Explain

From: <https://serviciostelematicosext.hacienda.gob.es/SGFAL/CONPREL>

```{r}
unique(odbc::odbcListDrivers()[[1]])

dbname <- "C:/Users/frede/Documents/Master Thesis II/master-thesis/Data/Liquidaciones2022.accdb"

con <- RODBC::odbcConnectAccess2007(dbname)

RODBC::sqlTables(con)
```

Getting tables I want –\> keeping cdfgr as character to keep preceeding zeroes

```{r}
tb_funcionalPorEntes <- RODBC::sqlFetch(con, "v_funcionalPorEntes", 
                                        as.is = c(F, F, F, F, F, F, F, T, F, F, F))

tb_cuentasProgramas <- RODBC::sqlFetch(con, "tb_cuentasProgramas",
                                       as.is = TRUE)
```

## Processing municipal spending data

### Applying official classification

Joining codigo municipio for official classification

Creating common ID

```{r}
codigo_municipio <- read_excel("Data/diccionario24.xlsx", skip = 1, col_names = TRUE) |> 
  mutate(INE = paste0(CPRO, CMUN),
         Provincia = as.integer(CPRO))

tb_funcionalPorEntes <- 
  tb_funcionalPorEntes |>
  mutate(INE = as.character(str_extract_all(CodBDGEL, "^\\d+")))
```

Joining

```{r}
tb_funcionalPorMunicipios <- 
  tb_funcionalPorEntes |> 
  inner_join(codigo_municipio, by = "INE") |> 
  inner_join(tb_cuentasProgramas, by ="cdfgr")
```

### Organizing spending data per municipality

Standardizing codification and reducing number of spending reasons

```{r}
Madrid <- tb_funcionalPorMunicipios |> 
  arrange(poblacion) |> 
  slice_head(n = 30) |> 
  select(INE, cdfgr, importe, nombre)

```

What variables do I want to have?

Only codes with two characters

-   more fine grained than the overarching descriptions but not too fine grained to produce

-   not too fine grained to create too many variables

-   Problem: certain municipalities will not have had an expenditure for every two charachter reason

Also, deleting all mancomunidades from the dataframe.

Also deleting every Entidad de ámbito territorial inferior al municipio (EATIM)

-   NOMBRE from codigo_municipio and NombreEnte form database

```{r}
tb_funcionalPorMunicipios <-
  tb_funcionalPorMunicipios |> 
  mutate(cdfgr = trimws(as.character(cdfgr)),
         NombreEnte = trimws(as.character(NombreEnte)),
         NOMBRE = trimws(as.character(NOMBRE))) |> 
  filter(nchar(cdfgr) == 2 & !str_detect(NombreEnte, "^Mc") 
         & NombreEnte == NOMBRE)
```

Total spending per reason

Group by 'cdfgr' and 'INE', then calculate the (total) sum of spending

```{r}
summarized_spending <- tb_funcionalPorMunicipios |> 
  group_by(cdfgr, INE) |> 
  summarize(total_spending = sum(importe)) |> 
  ungroup()

total_importePorMunicipio <- tb_funcionalPorMunicipios |> 
  group_by(INE) |> 
  summarize(total_importe = sum(importe)) |> 
  ungroup()
```

Keeping only one spending amount and spending reason per municipality

```{r}
tb_importePorPrograma <-
  tb_funcionalPorMunicipios |> 
  left_join(summarized_spending, by = c("cdfgr", "INE")) |>
  left_join(total_importePorMunicipio, by = "INE") |> 
  group_by(INE, cdfgr) |> 
  distinct(cdfgr, .keep_all = T) |> 
  ungroup()

# verifying that each funds destination is only listed once now per municipality
verification1 <-
  tb_importePorPrograma |> 
  filter(INE == "02001") |> 
  count(cdfgr)
```

Now calculating the share of each spending

```{r}
tb_partedeImporte <-
  tb_importePorPrograma |> 
  group_by(INE) |>
  mutate(share_spending = (total_spending/total_importe)*100) |> 
  ungroup()

# verifying that each funds destination is only listed once now per municipality
verification2 <-
  tb_importePorPrograma |> 
  group_by(INE) |>
  mutate(share_spending = (total_spending/total_importe)*100) |>
  ungroup() |> 
  filter(INE == "28079") |> 
  count(cdfgr)
```

Pivoting this data frame wider

```{r}
df_spending_mun_tidy <-
  tb_partedeImporte |> 
  select(INE, NombreEnte, CODAUTO, CPRO, CMUN, DC, NOMBRE, nombre, share_spending, total_importe) |> 
  pivot_wider(names_from = nombre,
              values_from = share_spending)
```

Imputing zeroes as NAs mean that the municipality did not spend money on a given end.

```{r}
df_spen_imp_mun_tidy <- 
  df_spending_mun_tidy |> 
  mutate_if(is.numeric, ~ifelse(is.na(.), 0, .))
```

### Number of municipalities

```{r}
n_distinct(df_spen_imp_mun_tidy$INE)
```

6181 municipalities

Where is the difference

```{r}
m <-
  df_spen_imp_mun_tidy |>
  mutate(CODAUTO_data = CODAUTO) |> 
  group_by(CODAUTO_data) |> 
  distinct(INE) |> 
  count(CODAUTO_data)
# adding missing community 
new_row <- data.frame(CODAUTO_data = "19", n = 0)
m <- m |> 
  bind_rows(new_row)

o <- 
  codigo_municipio |>
  mutate(CODAUTO_original = CODAUTO) |> 
  group_by(CODAUTO_original) |> 
  distinct(INE) |> 
  count(CODAUTO_original)

difference_n_mun <- o |> 
  left_join(m, by = c("CODAUTO_original"= "CODAUTO_data")) |> 
  mutate(difference = n.x - n.y,
         proportion = (difference/n.x)*100)

plot1 <-
  difference_n_mun |> 
  ggplot()+
  geom_col(aes(CODAUTO_original, proportion)) +
  geom_text(aes(CODAUTO_original, proportion, label = paste(round(proportion, 2),"%")),
            vjust = -0.4,
            size = 2.5) +
  labs(title = "Share of missing Municipalities by Autonomous Region") +
  theme_minimal()

ggsave("Plotting missing municipalities.png", bg = "white")
```

### Final data set for expenditure per municipality

```{r}
head(df_spen_imp_mun_tidy)
```

### Deleting remaining objects

```{r}
objects <- ls()
object_to_keep <- "df_spen_imp_mun_tidy"
objects_to_remove <- objects[objects != object_to_keep]
rm(list = objects_to_remove)
```

## Contracts

Contrato: <https://datos.gob.es/es/catalogo/ea0021425-contratos-por-municipios>

Manually changed data type to xlsx because csv did not work

Idea: Adding contracts and those who register as unemployed to calculate labor force - then calculate unemployement rate



```{r}
contratos <- 
  read_xlsx("Data/Contratos_por_municipios_2023.xlsx", skip = 1) |> 
  select("mes", "Codigo Municipio", "Municipio", "Total Contratos") |> 
  rename(INE = "Codigo Municipio",
         NOMBRE = Municipio,
         Contratos_total = "Total Contratos") |> 
  mutate(INE = ifelse(nchar(INE) == 4, paste0("0", INE), INE)) |> # 2.5 because in between 0 and 5
  mutate(Contratos_total = ifelse(Contratos_total == "<5", 2.5, as.numeric(Contratos_total)))
```

## Distance From Provincial Capital

Adding distance from provincial capital for proxy for inter-municipal mobility

Code provided by Villamil

```{r}
source(distcap)
```

Changing data type of and adding a 0 in front of every INE code that only has 4 characters to standardize and render the code applicable.

```{r}
distcap <- 
  distcap |> 
  mutate(muni_code = as.character(muni_code)) |> 
  mutate(muni_code = ifelse(nchar(muni_code) == 4, paste0("0", muni_code), muni_code)) |> 
  rename(INE = muni_code)
```

Merging tables

```{r}
df_spen_imp_mun_tidy <- 
  df_spen_imp_mun_tidy |> 
  left_join(distcap, by = c("INE" = "INE"))
```

## Population statistic

### Age groups

<https://www.ine.es/jaxiT3/Tabla.htm?t=33571&L=0>

```{r}
population <- 
  read_excel("Data/pop_mun_2022.xlsx", skip = 7, col_names = TRUE) |> 
  rename(municipio = ...1) 

population <- 
  population |> 
  filter(municipio == "1 de enero de 2022" | lead(municipio) == "1 de enero de 2022") |> 
  mutate(across(.cols = -municipio, .fns = lead)) |> 
  slice(-n()) |> 
  filter(municipio != "1 de enero de 2022") |>
  mutate(municipio = str_replace(municipio, "^(\\S+) ", "\\1_")) |> 
  separate(municipio, into = c("INE", "NOMBRE"), sep = "_") |> 
  select(INE, NOMBRE, "Todas las edades...2", "Menos de 16 años...3", "De 16 a 64 años...4", "65 y más años...5", "Todas las edades...10") |> 
  rename("pop_total" = "Todas las edades...2",
        "pop_below_16" = "Menos de 16 años...3",
        "pop_16_64" = "De 16 a 64 años...4",
        "pop_above_65" = "65 y más años...5",
        "pop_foreigners" = "Todas las edades...10") |> 
  mutate(pop_share_foreigners = (pop_foreigners/pop_total)*100)

# the population table stores values for Men and Women in rows rather than columns
# grouping by municipality and only choosing highest total population

population <- 
  population |> 
  group_by(INE) |> 
  slice_max(order_by = !!sym("pop_total"), n = 1) |> 
  ungroup() 
```

```{r}
population_national <- 
  population |>
  filter(INE == "Total") |> 
  mutate(INE = "00") |> 
  rename(CODAUTO = INE) |> 
  select(-NOMBRE)
```

```{r}
population <- 
  population |> 
  filter(INE != "Total") |> 
  drop_na()
```

### Average age

```{r}
read_excel("Data/avg_age_2022.xlsx")
```


## Number of firms

<https://www.ine.es/jaxiT3/Tabla.htm?t=4721&L=0>

Warning message because of notation in original table of 0 as ".".

```{r}
n_companías <- 
  read_excel("Data/n_firms_total.xlsx", skip = 7, col_names = TRUE) |> 
  rename(municipio = ...1,
         n_companías = "2022") |>
  drop_na() |> # dropping end of table
  mutate(n_companías = as.numeric(n_companías),
         municipio = str_replace(municipio, "^(\\S+) ", "\\1_")) |> 
  separate(municipio, into = c("INE", "NOMBRE"), sep = "_") |> 
  mutate(n_companías = ifelse(is.na(n_companías), 0, n_companías))
```

## Unemployment

2023 data for unemployment

Paro: <https://datos.gob.es/es/catalogo/ea0021425-paro-registrado-por-municipios>

Social Security: https://www.seg-social.es/wps/portal/wss/internet/EstadisticasPresupuestosEstudios/Estadisticas/est8/est10/est305/c43ad8ea-fe79-4329-ac8e-e5758f3c4d7a/6609c55f-65e4-4e64-b1ab-8917fce27a84

Unemployment = Paro / Paro + Social Security

```{r}
unemployment <- 
  read_xlsx("Data/Paro_por_municipios_2023.xlsx", skip = 1) |> 
  select("mes", "Codigo Municipio", "Municipio", "total Paro Registrado", "Paro Sin empleo Anterior") |> 
  rename(INE = "Codigo Municipio",
         NOMBRE = Municipio,
         Paro_total = "total Paro Registrado") |> 
  mutate(INE = ifelse(nchar(INE) == 4, paste0("0", INE), INE)) |> # 2.5 because in between 0 and 5
  mutate(Paro_total = ifelse(Paro_total == "<5", 2.5, as.numeric(Paro_total)))
```
Social Security data for active population

Reading data

```{r}
# Setting the directory path where csv files are located
folder_path <- "Data/SS"

# Getting a list of csv files in the folder
excel_files <- list.files(folder_path, full.names = TRUE)

# Initializing an empty list to store data frames
all_data <- list()

# Looping through each csv file and read it into a data frame
for (file in excel_files) {

  data <- read_excel(file, skip = 1)
  
  # Append the data frame to the list
  all_data[[length(all_data) + 1]] <- data
}

# Combine all data frames into a single object
social_security <- bind_rows(all_data)
```


Wrangling data

```{r}
social_security <- 
  social_security |> 
  mutate(MUNICIPIO = str_replace(MUNICIPIO, "^(\\S+) ", "\\1_")) |> 
  separate(MUNICIPIO, into = c("INE", "NOMBRE"), sep = "_") |> 
  mutate(TOTAL_SS = gsub("\\.", "", TOTAL)) |> # deleting dots
  mutate(TOTAL_SS = as.numeric(str_extract(TOTAL_SS, "\\d+"))) |>  # extracting only the numbers
  select(INE, NOMBRE, TOTAL_SS) |> 
  drop_na(TOTAL_SS) |> 
  group_by(INE) |> 
  summarise(mean_ss = mean(TOTAL_SS, rm.na = T)) |> 
  ungroup()
```

Merging with unemployment table

```{r}
unemployment <- 
  unemployment |> 
  group_by(INE, NOMBRE) |> 
  summarise(mean_ue = mean(Paro_total)) |> 
  ungroup() |> 
  left_join(social_security, by = "INE") |> 
  select(INE, NOMBRE, mean_ue, mean_ss) |> 
  mutate(ue_pct = (mean_ue/(mean_ue + mean_ss))*100) |> 
  drop_na()
```

```{r}
unemployment |> 
  summarise(ue = sum(mean_ue), ss = sum(mean_ss)) |>
  mutate(ue_pct = (ue/(ue + ss))*100)
```
Divergence of only 0.1%

```{r}
unemployment <- 
  unemployment |> 
  select(INE, ue_pct)
```

