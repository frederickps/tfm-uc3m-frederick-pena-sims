---
title: "Master Thesis - Fetching and processing Data"
author: "Frederick Pena Sims"
format: html
editor: visual
---

## Library

```{r}
# |echo: false

library(odbc)
library(RODBC)
library(tidyverse)
library(readxl)
```

## Getting municipal spending data

Explain

```{r}
unique(odbc::odbcListDrivers()[[1]])

dbname <- "C:/Users/frede/Documents/Master Thesis II/master-thesis/Liquidaciones2022.accdb"

con <- RODBC::odbcConnectAccess2007(dbname)

RODBC::sqlTables(con)
```

Getting tables I want –\> keeping cdfgr as character to keep preceeding zeroes

```{r}
tb_funcionalPorEntes <- RODBC::sqlFetch(con, "v_funcionalPorEntes", 
                                        as.is = c(F, F, F, F, F, F, F, T, F, F, F))

tb_cuentasProgramas <- RODBC::sqlFetch(con, "tb_cuentasProgramas",
                                       as.is = TRUE)
```

## Processing municipal spending data

### Applying official classification

Joining codigo municipio for official classification

Creating common ID

```{r}
codigo_municipio <- read_excel("diccionario24.xlsx", skip = 1, col_names = TRUE) |> 
  mutate(INE = paste0(CPRO, CMUN),
         Provincia = as.integer(CPRO))

tb_funcionalPorEntes <- 
  tb_funcionalPorEntes |>
  mutate(INE = as.character(str_extract_all(CodBDGEL, "^\\d+")))
```

Joining

```{r}
tb_funcionalPorMunicipios <- 
  tb_funcionalPorEntes |> 
  inner_join(codigo_municipio, by = "INE") |> 
  inner_join(tb_cuentasProgramas, by ="cdfgr")
```

### Organizing spending data per municipality

Standardizing codification and reducing number of spending reasons

```{r}
Madrid <- tb_funcionalPorMunicipios |> 
  arrange(poblacion) |> 
  slice_head(n = 30) |> 
  select(INE, cdfgr, importe, nombre)

```

What variables do I want to have?

Only codes with two characters

-   more fine grained than the overarching descriptions but not too fine grained to produce

-   not too fine grained to create too many variables

-   Problem: certain municipalities will not have had an expenditure for every two charachter reason

Also, deleting all mancomunidades from the dataframe.

Also deleting every Entidad de ámbito territorial inferior al municipio (EATIM)

-   NOMBRE from codigo_municipio and NombreEnte form database

```{r}
tb_funcionalPorMunicipios <-
  tb_funcionalPorMunicipios |> 
  mutate(cdfgr = trimws(as.character(cdfgr)),
         NombreEnte = trimws(as.character(NombreEnte)),
         NOMBRE = trimws(as.character(NOMBRE))) |> 
  filter(nchar(cdfgr) == 2 & !str_detect(NombreEnte, "^Mc") 
         & NombreEnte == NOMBRE)
```

Total spending per reason

Group by 'cdfgr' and 'INE', then calculate the (total) sum of spending

```{r}
summarized_spending <- tb_funcionalPorMunicipios |> 
  group_by(cdfgr, INE) |> 
  summarize(total_spending = sum(importe)) |> 
  ungroup()

total_importePorMunicipio <- tb_funcionalPorMunicipios |> 
  group_by(INE) |> 
  summarize(total_importe = sum(importe)) |> 
  ungroup()
```

Keeping only one spending amount and spending reason per municipality

```{r}
tb_importePorPrograma <-
  tb_funcionalPorMunicipios |> 
  left_join(summarized_spending, by = c("cdfgr", "INE")) |>
  left_join(total_importePorMunicipio, by = "INE") |> 
  group_by(INE, cdfgr) |> 
  distinct(cdfgr, .keep_all = T) |> 
  ungroup()

# verifying that each funds destination is only listed once now per municipality
verification1 <-
  tb_importePorPrograma |> 
  filter(INE == "02001") |> 
  count(cdfgr)
```

Now calculating the share of each spending

```{r}
tb_partedeImporte <-
  tb_importePorPrograma |> 
  group_by(INE) |>
  mutate(share_spending = (total_spending/total_importe)*100) |> 
  ungroup()

# verifying that each funds destination is only listed once now per municipality
verification2 <-
  tb_importePorPrograma |> 
  group_by(INE) |>
  mutate(share_spending = (total_spending/total_importe)*100) |>
  ungroup() |> 
  filter(INE == "28079") |> 
  count(cdfgr)
```

Pivoting this data frame wider

```{r}
df_spending_mun_tidy <-
  tb_partedeImporte |> 
  select(INE, NombreEnte, CODAUTO, CPRO, CMUN, DC, NOMBRE, nombre, share_spending, total_importe) |> 
  pivot_wider(names_from = nombre,
              values_from = share_spending)
```

Imputing zeroes as NAs mean that the municipality did not spend money on a given end.

```{r}
df_spen_imp_mun_tidy <- 
  df_spending_mun_tidy |> 
  mutate_if(is.numeric, ~ifelse(is.na(.), 0, .))
```

### Number of municipalities

```{r}
n_distinct(df_spen_imp_mun_tidy$INE)
```

6181 municipalities

Where is the difference

```{r}
m <-
  df_spen_imp_mun_tidy |>
  mutate(CODAUTO_data = CODAUTO) |> 
  group_by(CODAUTO_data) |> 
  distinct(INE) |> 
  count(CODAUTO_data)

o <- 
  codigo_municipio |>
  mutate(CODAUTO_original = CODAUTO) |> 
  group_by(CODAUTO_original) |> 
  distinct(INE) |> 
  count(CODAUTO_original)

difference_n_mun <- o |> 
  left_join(m, by = c("CODAUTO_original"= "CODAUTO_data")) |> 
  mutate(difference = n.x - n.y,
         proportion = (difference/n.x)*100)

plot1 <-
  difference_n_mun |> 
  ggplot()+
  geom_col(aes(CODAUTO_original, proportion)) +
  geom_text(aes(CODAUTO_original, proportion, label = paste(round(proportion, 2),"%")),
            vjust = -0.4,
            size = 2.5) +
  labs(title = "Share of missing Municipalities by Autonomous Region")

ggsave("Plotting missing municipalities.png")
```

### Final data set for expenditure per municipality

```{r}
head(df_spen_imp_mun_tidy)
```
