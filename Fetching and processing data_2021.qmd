---
title: "Master Thesis - Fetching and processing Data"
author: "Frederick Pena Sims"
format: html
editor: visual
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
```

## Library

```{r setup, include=FALSE}
options(scipen = 999)
library(devtools)
library(odbc)
library(RODBC)
library(tidyverse)
library(readxl)
library(DBI)
library(stringr)
```

## Municipal spending data

Spending and revenue data is taken from the [Ministry for Finance](https://serviciostelematicosext.hacienda.gob.es/SGFAL/CONPREL) and is provided as a Microsoft Access file. Hence a connection is first established.

```{r}
unique(odbc::odbcListDrivers()[[1]])

# change into adequate source
dbname <- "C:/Users/frede/Documents/Master Thesis II/master-thesis/Data_2020/Liquidaciones2020.mdb" 

con <- dbConnect(odbc::odbc(),
                 Driver = "Microsoft Access Driver (*.mdb, *.accdb)",
                 DBQ = dbname)

tables <- dbListTables(con)

# to gain insights into names of available tables
print(tables)
```

Tables are identified and subsequently loaded into the environment. To keep the code classifying the purpose of a given expenditure as is - with leading 0s - it is classified as a character variable.

```{r}

tb_funcionalPorEntes <- dbReadTable(con, "v_funcionalPorEntes", colClasses = c(F, F, F, F, F, F, F, "character", F, F, F))

tb_cuentasProgramas <- dbReadTable(con, "tb_cuentasProgramas")
```

Now, Autonomous Community and Province association willbe added. Moreover, by performing an `inner_join()` only municipalities matched by the official registry of Spanish municipalities, gathered on the Instituto Nacional de Estadísticas (INE), deleting non-eligible local entities. Finally, the information on the purpose of expenditure is added.

```{r}
codigo_municipio <- read_excel("Data_2020/diccionario24.xlsx", skip = 1, col_names = TRUE) |> 
  mutate(INE = paste0(CPRO, CMUN),
         Provincia = as.integer(CPRO)) # creating INE code from province and municipalitiy code

tb_funcionalPorEntes <- 
  tb_funcionalPorEntes |>
  mutate(INE = as.character(str_extract_all(CodBDGEL, "^\\d+"))) # extracting INE code

tb_funcionalPorMunicipios <- 
  tb_funcionalPorEntes |> 
  inner_join(codigo_municipio, by = "INE") |> 
  inner_join(tb_cuentasProgramas, by ="cdfgr") # adding the purposes 
```

Next, both municipalities and purpose of expenditure need to be cleaned. Concerning municipalities, only entities not beginning with "Mc" - identifying Mancomunidades - and with concurring names in the official registry and the original table from the spending data. For the expenditure purpose, only those classifications with two characters are kept. Expenditure purposes are classified modular, with the first digit providing information on a very broad level of the purpose of expenditure, with every added digit giving more fine-grained information. At the same time each superior level encloses the amount of money spent on a given purpose.

Take, for example, digit "1" identifying expenditure on the administration. "11" may identify expenditure on public employees while "12" may refer to upkeep of public buildings. At most, four digit codes classify expenditure. Every amount related to any digit code starting with "1" is reflected in the amount coinciding with digit "1".

```{r}
tb_funcionalPorMunicipios <-
  tb_funcionalPorMunicipios |> 
  mutate(cdfgr = trimws(as.character(cdfgr)), # trimming to get rid of blank spaces
         NombreEnte = trimws(as.character(NombreEnte)), 
         NOMBRE = trimws(as.character(NOMBRE))) |> 
  filter(nchar(cdfgr) == 2 & !str_detect(NombreEnte, "^Mc") 
         & NombreEnte == NOMBRE)
```

Following, two values are created. `total_spending` refers to the sum of all spending per municipality on a given expenditure purpose. `total_importe` refers to the total spending per municipality. Each values are stored in separate data frames and then joined.

```{r}
summarized_spending <- tb_funcionalPorMunicipios |> 
  group_by(cdfgr, INE) |> 
  summarize(total_spending = sum(importe)) |> 
  ungroup()

total_importePorMunicipio <- tb_funcionalPorMunicipios |> 
  group_by(INE) |> 
  summarize(total_importe = sum(importe)) |> 
  ungroup()
```

```{r}
tb_importePorPrograma <-
  tb_funcionalPorMunicipios |> 
  left_join(summarized_spending, by = c("cdfgr", "INE")) |> # adding spending per municipality and expenditure purpose
  left_join(total_importePorMunicipio, by = "INE") |> # adding total spending per municipality
  group_by(INE, cdfgr) |> 
  distinct(cdfgr, .keep_all = T) |> # to make sure only one expenditure purpose per municipality and expenditure purpose is kept
  ungroup()
```

Now, share of spending for every expenditure purpose is calculated.

```{r}
tb_partedeImporte <-
  tb_importePorPrograma |> 
  group_by(INE) |>
  mutate(share_spending = (total_spending/total_importe)*100) |> 
  ungroup() |> 
  mutate(nombre = trimws(nombre))
```

To generate a tidy data frame, the data is pivoted wider.

```{r}
df_spending_mun_tidy <-
  tb_partedeImporte |> 
  select(INE, NOMBRE, CODAUTO, CPRO, nombre, share_spending, total_importe) |> 
  pivot_wider(names_from = nombre,
              values_from = share_spending)
```

Since some municipalities di not spend any money on a given purpose, NAs are imputed with 0.

```{r}
df_spen_imp_mun_tidy <- 
  df_spending_mun_tidy |> 
  mutate_if(is.numeric, ~ifelse(is.na(.), 0, .)) |> 
  rename(total_MUN = total_importe)
```

```{r}
n_distinct(df_spen_imp_mun_tidy$INE)
```

6358 municipalities are left in the data.

```{r}
head(df_spen_imp_mun_tidy)
```

## Municipal revenue data

Municipal revenue data is recovered very similarly, as it is stored in the same data base.

```{r}
tb_economicaPorEntes <- dbReadTable(con, "v_economicaPorEntes", colClasses = c(F, F, F, F, F, F, F, "character", F, F, F))

tb_cuentasEconomica <- dbReadTable(con, "tb_cuentasEconomica")
```

Revenue is stored under "I" and is subsequently filtered out of the data containing amounts and source, respectively. This time only sources at the level of 1 charahter are kept, since such fine-grained infromation is not necessary for this set of data. Names of municipalities are added for cross-checking. Using the same technique as before, all non-eligible local entities are filtered out.

```{r}
tb_economicaPorEntes <- 
  tb_economicaPorEntes |> 
  filter(tipreig == "I")|>
  mutate(INE = as.character(str_extract_all(CodBDGEL, "^\\d+")))

# keeping only Importe (revenue)
tb_cuentasEconomica <- 
  tb_cuentasEconomica |> 
  filter(tipreig == "I") |> 
  select(-tipreig)

tb_economicaPorMunicipios <- 
  tb_economicaPorEntes |> 
  inner_join(codigo_municipio, by = "INE") |> 
  inner_join(tb_cuentasEconomica, by ="cdcta")
```

```{r}
tb_economicaPorMunicipios <- 
  tb_economicaPorMunicipios |> 
  mutate(cdcta = trimws(as.character(cdcta)),
         NombreEnte = trimws(as.character(NombreEnte)),
         NOMBRE = trimws(as.character(NOMBRE))) |> 
  filter(nchar(cdcta) == 1 & !str_detect(NombreEnte, "^Mc") 
         & NombreEnte == NOMBRE)
```

### Adding total spending (per reason)

Tota revenue and total revenue per source are calculated from the variable `importer` which refers to the revenues that have been formally acknowledged by the municipalitiy for the given fiscal year.

```{r}
summarized_revenue <- tb_economicaPorMunicipios |> 
  group_by(cdcta, INE) |> 
  summarize(total_revenue_per_source = sum(importer)) |> 
  ungroup()

total_revenuePorMunicipio <- tb_economicaPorMunicipios |> 
  group_by(INE) |> 
  summarize(total_revenue_per_mun = sum(importer)) |> 
  ungroup()
```

The values are joined.

```{r}
tb_revenue_per_source <-
  tb_economicaPorMunicipios |> 
  left_join(summarized_revenue, by = c("cdcta", "INE")) |>
  left_join(total_revenuePorMunicipio, by = "INE") |> 
  group_by(INE, cdcta) |> 
  distinct(cdcta, .keep_all = T) |> 
  ungroup() |> 
  select(INE, NOMBRE, nombre, total_revenue_per_source, total_revenue_per_mun)
```

To classify the information more broadly, revenue information is pivoted wider, renamed to be more legible, and summed up accordingly. Lastly, shares of total revenues are calculated.

```{r}
revenue_municipality_final <- 
  tb_revenue_per_source |> 
  pivot_wider(names_from = nombre,
              values_from = total_revenue_per_source) |> 
  rename(direct_taxes = `CAP. I IMPUESTOS DIRECTOS                                                                                                    `,
         indirect_taxes = `CAP. II IMPUESTOS INDIRECTOS                                                                                                 `,
         fees_other_revenues = `CAP. III TASAS Y OTROS INGRESOS                                                                                              `,
         current_transfers = `CAP. IV  TRANSFERENCIAS CORRIENTES                                                                                           `,
         property_income = `CAP. V INGRESOS PATRIMONIALES                                                                                                `,
         sale_investments = `CAP. VI ENAJENACIÓN DE INVERSIONES REALES                                                                                    `,
         capital_transfers = `CAP. VII TRANSFERENCIAS DE CAPITAL                                                                                           `,
        
         financial_assets = `CAP. VIII ACTIVOS FINANCIEROS                                                                                                `,
         financial_liabilities = `CAP. IX PASIVOS FINANCIEROS                                                                                                  `) |> 
  mutate_if(is.numeric, ~ifelse(is.na(.), 0, .)) |> 
  rename(total_revenue_MUN = total_revenue_per_mun) |> 
  mutate(revenue_tax = fees_other_revenues + direct_taxes + indirect_taxes,
         revenue_grants = current_transfers + capital_transfers,
         revenue_other = financial_assets + financial_liabilities + property_income + sale_investments) |> 
  mutate(revenue_tax_share = revenue_tax/total_revenue_MUN,
         revenue_grants_share = revenue_grants/total_revenue_MUN,
         revenue_other_share = revenue_other/total_revenue_MUN) |> 
  select(INE, revenue_tax_share, revenue_grants_share, revenue_other_share)
```

## Autonomous community expenditure

Expenditure information for Autonomous Communities is also found on the [Ministry for Finance'](https://www.igae.pap.hacienda.gob.es/sitios/igae/es-ES/Contabilidad/ContabilidadNacional/Publicaciones/Paginas/iacofogCA.aspx)webpage, however stored in one excel file with multiple pages, each page providing information on one Autonomous Community.

Since the procedure is repetitive, a function is created.

```{r}
spending_CCAA <- 
  function(data_file, sheet, CCAA){ # CCAA refers to the official CCAA code
  data <-
    read_excel(paste0("Data_2020/", data_file),
             sheet = sheet, skip = 6) |> 
    filter(...2 == "GASTO TOTAL") |> 
  rename(total = "\r\nTOTAL",
         ccaa_general_services = "\r\n01. Servicios públicos generales",
         ccaa_security = "\r\n03. Orden público y seguridad",
         ccaa_economic = "\r\n04. Asuntos económicos",
         ccaa_housing_services = "\r\n06. Vivienda y servicios comunitarios",
         ccaa_health = "07.Salud",
         ccaa_culture = "\r\n08. Ocio, cultura y religión",
         ccaa_social_protection = "\r\n10. Protección social",
         CODAUTO = ...2
) |> 
  select(CODAUTO, total, ccaa_general_services, ccaa_security, ccaa_economic, ccaa_housing_services, ccaa_health, ccaa_culture, ccaa_social_protection) |> 
  mutate(across(2:9, ~ . * 1000000)) # adjusting the metric
  
data$CODAUTO <- CCAA
  
assign(paste0("CCAA_", CCAA), data, envir = .GlobalEnv)
  }
```

```{r}
# CCAA 01
spending_CCAA("CCAA_spending_2020.xlsx", 3, "01")


# CCAA 02
spending_CCAA("CCAA_spending_2020.xlsx", 4, "02")

# CCAA 03
spending_CCAA("CCAA_spending_2020.xlsx", 5, "03")

# CCAA 04
spending_CCAA("CCAA_spending_2020.xlsx", 6, "04")

# CCAA 05
spending_CCAA("CCAA_spending_2020.xlsx", 7, "05")

# CCAA 06
spending_CCAA("CCAA_spending_2020.xlsx", 8, "06")

# CCAA 07
spending_CCAA("CCAA_spending_2020.xlsx", 10, "07")

# CCAA 08
spending_CCAA("CCAA_spending_2020.xlsx", 9, "08")

# CCAA 09
spending_CCAA("CCAA_spending_2020.xlsx", 11, "09")

# CCAA 10
spending_CCAA("CCAA_spending_2020.xlsx", 18, "10")

# CCAA 11
spending_CCAA("CCAA_spending_2020.xlsx", 12, "11")

# CCAA 12 
spending_CCAA("CCAA_spending_2020.xlsx", 14, "12")

# CCAA 13
spending_CCAA("CCAA_spending_2020.xlsx", 13, "13")

# CCAA 14
spending_CCAA("CCAA_spending_2020.xlsx", 15, "14")

# CCAA 15
spending_CCAA("CCAA_spending_2020.xlsx", 16, "15")

# CCAA 16
spending_CCAA("CCAA_spending_2020.xlsx", 19, "16")

# CCAA 17
spending_CCAA("CCAA_spending_2020.xlsx", 17, "17")

spending_CCAA_objects <- mget(ls(pattern = "^CCAA"))
spending_CCAA <- do.call(rbind, spending_CCAA_objects)
```

To provide expenditure information not only as share but also per capita (for total expenditure) population information for 2020 is added from the statistical office from [Murcia](https://econet.carm.es/inicio/-/crem/sicrem/PU_padron/cifof10/sec2_c1.html).

```{r}
pop_CCAA <- 
  read_excel("Data_2020/pop_CCAA_2020.xlsx", skip = 4) |> 
  filter(...1 != "ESPAÑA",
         str_detect(substr(...1, 1, 2), "^[A-Z]+$")) |> 
  mutate(CODAUTO = row_number()) |> 
  select(...1, CODAUTO, "2020") |> 
  rename(pop_2020 = "2020") |> 
  mutate(CODAUTO = as.character(ifelse(nchar(CODAUTO) == 1, paste0("0", CODAUTO), CODAUTO)))
```

Population data for 2020 is joined and shares are created.

```{r}
spending_CCAA_final <- 
  spending_CCAA |> 
  left_join(pop_CCAA, by = "CODAUTO") |> 
  mutate(share_ccaa_general_services = (ccaa_general_services/total)*100,
         share_ccaa_security = (ccaa_security/total)*100,
         share_ccaa_economic = (ccaa_economic/total)*100,
         share_ccaa_housing_services = (ccaa_housing_services/total)*100,
         share_ccaa_culture = (ccaa_culture/total)*100,
         share_ccaa_social_protection = (ccaa_social_protection/total)*100,
         per_capita_CCAA = total/pop_2020) |> 
  rename(total_CCAA = total) |> 
  select(CODAUTO, total_CCAA, per_capita_CCAA,share_ccaa_general_services, share_ccaa_security, share_ccaa_economic, share_ccaa_housing_services, share_ccaa_culture, share_ccaa_social_protection)
```

## Contracts

Information on newly added contracts to the job data base is added from [INE](https://datos.gob.es/es/catalogo/ea0021425-contratos-por-municipios).

Shares of contracts into different sectors are provided. Since data is given monthly, the mean share is calculated for every municipality.

```{r}
contracts <- 
  read_xlsx("Data_2020/Contratos_por_municipios_2020.xlsx", skip = 1) |> 
  select("mes", "Codigo Municipio", "Municipio", "Total Contratos", `Contratos  Agricultura`, `Contratos  Industria`, `Contratos Construcción`, `Contratos  Servicios`) |> 
  rename(INE = "Codigo Municipio",
         NOMBRE = Municipio,
         Contratos_total = "Total Contratos",
         Contratos_agri = `Contratos  Agricultura`,
         Contratos_indu = `Contratos  Industria`,
         Contratos_cons = `Contratos Construcción`,
         Contratos_serv = `Contratos  Servicios`) |> 
  mutate(INE = ifelse(nchar(INE) == 4, paste0("0", INE), INE)) |> # 2.5 because in between 0 and 5
  mutate(Contratos_total = ifelse(Contratos_total == "<5", 2.5, as.numeric(Contratos_total)),
         share_contracts_agri = if_else(Contratos_total == 0, 0,(Contratos_agri/Contratos_total)*100), # if no contracts there cannot be a share
         share_contracts_indu = if_else(Contratos_total == 0, 0,(Contratos_indu/Contratos_total)*100),
         share_contracts_con = if_else(Contratos_total == 0, 0,(Contratos_cons/Contratos_total)*100),
         share_contracts_serv = if_else(Contratos_total == 0, 0,(Contratos_serv/Contratos_total)*100)) |> 
  group_by(INE) |> 
  summarise(contracts_mean_2020 = mean(Contratos_total),
            share_contracts_agri = mean(share_contracts_agri, na.rm = T),
            share_contracts_indu = mean(share_contracts_indu, na.rm = T),
            share_contracts_con = mean(share_contracts_con, na.rm = T),
            share_contracts_serv = mean(share_contracts_serv, na.rm = T))
```

## Geographical information

Geographical information on the distance from the provincial capital, and the area in square kilometer is added via the subsequent script.

```{r}
source("distcap.R")
```

To later join with remaining data, the INE code is adjusted.

```{r}
dist_cap <- 
  dist_cap |> 
  mutate(INE = as.character(INE)) |> 
  mutate(INE = ifelse(nchar(INE) == 4, paste0("0", INE), INE)) # adding a 0 if INE code only with four characters
```

## Population statistics

### Age groups

Age groups are recovered from [INE](https://www.ine.es/jaxiT3/Tabla.htm?t=33571&L=0). Shares of age groups are calculated.

```{r}
population <- 
  read_excel("Data_2020/pop_mun_2020.xlsx", skip = 7, col_names = TRUE) |> 
  rename(municipio = ...1) 

population <- 
  population |> 
  filter(municipio == "1 de enero de 2020" | lead(municipio) == "1 de enero de 2022") |> # INE and information on population are offset
  mutate(across(.cols = -municipio, .fns = lead)) |> # getting all information per municpality in one row
  dplyr::slice(-n()) |> 
  filter(municipio != "1 de enero de 2020") |>
  mutate(municipio = str_replace(municipio, "^(\\S+) ", "\\1_")) |> 
  separate(municipio, into = c("INE", "NOMBRE"), sep = "_") |> 
  select(INE, "Todas las edades...2", "Menos de 16 años...3", "De 16 a 64 años...4", "65 y más años...5", "Todas las edades...10") |> 
  rename("pop_total" = "Todas las edades...2",
        "pop_below_16" = "Menos de 16 años...3",
        "pop_16_64" = "De 16 a 64 años...4",
        "pop_above_65" = "65 y más años...5",
        "pop_foreigners" = "Todas las edades...10") |> 
  mutate(pop_share_foreigners = (pop_foreigners/pop_total)*100,
         pop_share_wk_age = (pop_16_64/pop_total)*100,
         pop_share_retirees = (pop_above_65/pop_total)*100,
         pop_share_youth = (pop_below_16/pop_total)*100) |> 
  select(INE, pop_share_foreigners, pop_share_wk_age, pop_share_retirees, pop_share_youth, pop_total)

# the population table stores values for Men and Women in rows rather than columns
# grouping by municipality and only choosing highest total population
population <- 
  population |> 
  group_by(INE) |> 
  slice_max(order_by = !!sym("pop_total"), n = 1) |> 
  ungroup() |> 
  filter(INE != "Total") |> 
  drop_na()
```

### Municipality size

From that data frame the factor variable `greater_20k` is calculated to differente between municipalities greater and equal or smaller than 20,000 inhabitants.

```{r}
population <- 
  population |> 
  mutate(greater_20k = as.factor(if_else(pop_total > 20000, 1,0)))
```

### Share women

More over, the share of women is calculated.

```{r}

share_women <- 
  read_excel("Data_2020/pop_mun_women.xlsx", skip = 7) |> 
  rename(municipio = Mujeres,
         num_women = ...2) |> 
  mutate(across(.cols = -municipio, .fns = lead)) |> 
  drop_na() |> 
  mutate(municipio = str_replace(municipio, "^(\\S+) ", "\\1_")) |> # replaces the space after the first word (INE) score with underscore and seperates it afterwards
  separate(municipio, into = c("INE", "NOMBRE"), sep = "_") |> # creates INE code
  left_join(population, by = "INE") |> # required for total population information
  mutate(share_women = (num_women/pop_total)*100) |> 
  select(INE, share_women)
```

### Average age

The average age is calculated from a data frame providing information on the absolute amount of people with a given age.

Information is stored in a separate data frame because processing the code takes too long.

```{r, eval=FALSE}
avg_age_raw <- 
  read_excel("Data_2020/avg_age_2020.xlsx", skip = 6)

avg_age_clean <- 
  avg_age_raw |>
  select(-"Todas las edades") |> 
  rename(municipio = ...1) |> 
  rename_with(~ if_else(. == "municipio", ., gsub("\\D", "", .)), everything()) |> 
  filter(municipio == "1 de enero de 2020" | lead(municipio) == "1 de enero de 2022") |> 
  mutate(across(.cols = -municipio, .fns = lead)) |> 
  slice(-n()) |> # again all information is moved into one row.
  filter(municipio != "1 de enero de 2020" & municipio != "Total Nacional") |> # national information is removed
  group_by(municipio) |> 
  slice(1) |> 
  ungroup()

#calculating weighted sum of age by pivoting data frame longer
weighted_sum_age <-
  avg_age_clean |>
  pivot_longer(cols = 2:102, names_to = "age") |> 
  mutate(age = as.numeric(age)) |> 
  mutate(weighted_age = age * value) |> 
  group_by(municipio) |> 
  summarize(weighted_sum = sum(weighted_age)) |> 
  ungroup()

# calculating the total population
total_n_people <-
  avg_age_clean |>
  pivot_longer(cols = 2:102, names_to = "age") |> 
  group_by(municipio) |> 
  summarize(total_people = sum(value)) |> 
  ungroup()

# adding the total population and calculating the average age from the weighted sum and total population
avg_age_final <- 
  weighted_sum_age |> 
  inner_join(total_n_people, by = "municipio") |> 
  mutate(average_age = weighted_sum / total_people) |> 
  mutate(MUNICIPIO = str_replace(municipio, "^(\\S+) ", "\\1_")) |> 
  separate(MUNICIPIO, into = c("INE", "NOMBRE"), sep = "_") |> 
  select(INE, average_age)
```

```{r, eval=FALSE}
write.csv(avg_age_final, "Data_2020/avg_age_final.csv")
```

```{r}
avg_age_final <- read.csv("Data_2020/avg_age_final.csv", colClasses = c(INE = "character")) |> 
  select (-X)
```

## Number of firms

Total numer of firms and share of firms in service sector are recovered from [INE](https://www.ine.es/jaxiT3/Tabla.htm?t=4721&L=0).

```{r}
n_firms  <- 
  read_excel("Data_2020/n_firms_total.xlsx", skip = 7, col_names = TRUE) |> 
  rename(municipio = ...1,
         n_firms = "2020...2",
         n_firms_service = "2020...3") |> # dropping end of table
  mutate(n_firms = as.numeric(n_firms),
         municipio = str_replace(municipio, "^(\\S+) ", "\\1_"),
         n_firms_service = as.numeric(n_firms_service),
         n_firms = ifelse(is.na(n_firms), 0, n_firms),
         n_firms_service = if_else(is.na(n_firms_service), 0, n_firms_service),
         share_firms_service = if_else(n_firms == 0, 0,(n_firms_service/n_firms)*100)) |> 
  separate(municipio, into = c("INE", "NOMBRE"), sep = "_") |> 
  select(-NOMBRE, -n_firms_service)
```

## DEA Outcome I - Difference in unemployment rate

The first outcome variable is the average monthly difference in unemployment between 2021 and 2020. Absolute unemployment data is recovered from [INE](https://datos.gob.es/es/catalogo/ea0021425-paro-registrado-por-municipios), while social security information is provided by the [Ministry for Social Security](https://www.seg-social.es/wps/portal/wss/internet/EstadisticasPresupuestosEstudios/Estadisticas/est8/est10/est305/c43ad8ea-fe79-4329-ac8e-e5758f3c4d7a/6609c55f-65e4-4e64-b1ab-8917fce27a84).

### 2021

To generate the monthly unemployment rate per municipality, unemployment and social security data are joined. Because social security data is only stored per province, a loop is created to load all the data.

```{r}
unemployment_2021 <- 
  read_xlsx("Data_2020/Paro_por_municipios_2021.xlsx", skip = 1) |> 
  select("mes", "Codigo Municipio", "Municipio", "total Paro Registrado") |> 
  rename(INE = "Codigo Municipio",
         NOMBRE = Municipio,
         Paro_total = "total Paro Registrado") |> 
  mutate(INE = ifelse(nchar(INE) == 4, paste0("0", INE), INE)) |> # 2.5 because in between 0 and 5
  mutate(Paro_total = ifelse(Paro_total == "<5", 2.5, as.numeric(Paro_total)))
```

```{r}
# Setting the directory path where csv files are located
folder_path <- "Data_2020/SS_2021"

# Getting a list of csv files in the folder
excel_files <- list.files(folder_path, full.names = TRUE)

# Initializing an empty list to store data frames
all_data <- list()

# Looping through each csv file and read it into a data frame
for (i in seq_along(excel_files)) {
  file <- excel_files[i]
  
  data <- read_excel(file, skip = 1)
  
  # Add a new column 'mes' with the value of i
  data$mes <- i
  
  # Append the data frame to the list
  all_data[[length(all_data) + 1]] <- data
}

# Combine all data frames into one if needed
social_security_2021 <- do.call(rbind, all_data)

social_security_2021 <- 
  social_security_2021 |> 
  mutate(MUNICIPIO = str_replace(MUNICIPIO, "^(\\S+) ", "\\1_")) |> 
  separate(MUNICIPIO, into = c("INE", "NOMBRE"), sep = "_") |> 
  mutate(TOTAL_SS = gsub("\\.", "", TOTAL)) |> # deleting dots
  mutate(TOTAL_SS = as.numeric(str_extract(TOTAL_SS, "\\d+"))) |>  # extracting only the numbers
  select(INE, TOTAL_SS, mes) |> 
  drop_na(TOTAL_SS) |> 
  mutate(mes = case_when(mes == 1 ~ "Enero de 2021",
                         mes == 2 ~ "Febrero de 2021",
                         mes == 3 ~ "Marzo de 2021",
                         mes == 4 ~ "Abril de 2021",
                         mes == 5 ~ "Mayo de 2021",
                         mes == 6 ~ "Junio de 2021",
                         mes == 7 ~ "Julio de 2021",
                         mes == 8 ~ "Agosto de 2021",
                         mes == 9 ~ "Septiembre de 2021",
                         mes == 10 ~ "Octubre de 2021",
                         mes == 11 ~ "Noviembre de 2021",
                         mes == 12 ~ "Diciembre de 2021"))
```

```{r}
unemployment_2021_monthly <- 
  unemployment_2021 |> 
  left_join(social_security_2021, by = c("INE", "mes")) |> 
  mutate(ue_mes_2021 = (Paro_total / (Paro_total + TOTAL_SS))*100) |> 
  select(mes, INE, ue_mes_2021)|> 
  mutate(mes = str_extract(mes, "^\\w+"))
```

### 2020

The same is done for 2020.

```{r}
unemployment_2020 <- 
  read_xlsx("Data_2020/Paro_por_municipios_2020.xlsx", skip = 1) |> 
  select("mes", "Codigo Municipio", "total Paro Registrado") |> 
  rename(INE = "Codigo Municipio",
         Paro_total = "total Paro Registrado") |> 
  mutate(INE = ifelse(nchar(INE) == 4, paste0("0", INE), INE)) |> # 2.5 because in between 0 and 5
  mutate(Paro_total = ifelse(Paro_total == "<5", 2.5, as.numeric(Paro_total)))
```

Because for every province, the unemployment data for december 2020 is not provided it is added mannually (from [here](https://www.sepe.es/HomeSepe/que-es-el-sepe/estadisticas/datos-estadisticos/municipios/2020/diciembre.html)).

```{r}
# Setting the directory path where csv files are located
folder_path <- "Data_2020/paro_diciembre_2020"

# Getting a list of csv files in the folder
excel_files <- list.files(folder_path, full.names = TRUE)

# Initializing an empty list to store data frames
all_data <- list()

# Looping through each csv file and read it into a data frame
for (i in seq_along(excel_files)) {
  file <- excel_files[i]
  
  data <- read_excel(file, skip = 6) |> 
  select("...1", "...3") |> 
  rename(INE = "...1",
         Paro_total = "...3") |> 
  mutate(mes = "Diciembre de 2020",
         INE = as.character(INE),
         INE = if_else(nchar(INE) == 4, paste0("0", INE), INE)) |> 
  drop_na()
  
  # Append the data frame to the list
  all_data[[length(all_data) + 1]] <- data
}

unemployment_2020_dec <- do.call(rbind, all_data)

# rbind to unemployment data
unemployment_2020 <- rbind(unemployment_2020, unemployment_2020_dec)
```

Again, social security information is recovered.

```{r, results='hide'}
# Setting the directory path where csv files are located
folder_path <- "Data_2020/SS_2020"

# Getting a list of csv files in the folder
excel_files <- list.files(folder_path, full.names = TRUE)

# Initializing an empty list to store data frames
all_data_2020 <- list()

# Looping through each csv file and read it into a data frame
for (i in seq_along(excel_files)) {
  file <- excel_files[i]
  
  data <- read_excel(file, skip = 1)
  
  # Add a new column 'mes' with the value of i
  data$mes <- i
  
  # Append the data frame to the list
  all_data_2020[[length(all_data_2020) + 1]] <- data
}

# column name mistakes rendered this step necessary --> selecting columns for every data frame in the list
for (i in seq_along(all_data_2020)) {
  all_data_2020[[i]] <- all_data_2020[[i]][, c("mes", "TOTAL", "MUNICIPIO")]
}

# Combine all data frames into one if needed
social_security_2020 <- do.call(rbind, all_data_2020)

social_security_2020 <- 
  social_security_2020 |> 
  mutate(MUNICIPIO = str_replace(MUNICIPIO, "^(\\S+) ", "\\1_")) |> 
  separate(MUNICIPIO, into = c("INE", "NOMBRE"), sep = "_") |> 
  mutate(TOTAL_SS = gsub("\\.", "", TOTAL)) |> # deleting dots
  mutate(TOTAL_SS = as.numeric(str_extract(TOTAL_SS, "\\d+"))) |>  # extracting only the numbers
  select(INE, TOTAL_SS, mes) |> 
  drop_na(TOTAL_SS, INE) |> 
  mutate(mes = case_when(mes == 1 ~ "Enero de 2020",
                         mes == 2 ~ "Febrero de 2020",
                         mes == 3 ~ "Marzo de 2020",
                         mes == 4 ~ "Abril de 2020",
                         mes == 5 ~ "Mayo de 2020",
                         mes == 6 ~ "Junio de 2020",
                         mes == 7 ~ "Julio de 2020",
                         mes == 8 ~ "Agosto de 2020",
                         mes == 9 ~ "Septiembre de 2020",
                         mes == 10 ~ "Octubre de 2020",
                         mes == 11 ~ "Noviembre de 2020",
                         mes == 12 ~ "Diciembre de 2020"))
# warning for rows that do not have an INE --> so no problem
```

```{r}
unemployment_2020_monthly <- 
  unemployment_2020 |> 
  left_join(social_security_2020, by = c("INE", "mes")) |> 
  mutate(ue_mes_2020 = (Paro_total / (Paro_total + TOTAL_SS))*100) |> 
  select(mes, INE, ue_mes_2020) |> 
  mutate(mes = str_extract(mes, "^\\w+"))
```

### Difference

Merging both data frames for 2020 and 2021, the monthly difference is calculated and subsequently, the yearly average is estimated.

```{r}
diff_ue <- 
  unemployment_2021_monthly |> 
  left_join(unemployment_2020_monthly, by = c("INE", "mes")) |> 
  mutate(diff_ue = ue_mes_2021 - ue_mes_2020) |> 
  group_by(INE) |> 
  summarise(diff_ue = mean(diff_ue, na.rm = T))
```

## Unemployment rate (2020)

Additionally, to the yearly unemployment rate for 2020, share of unemployed from specific sectors is added as variables.

```{r}
unemployment_2020 <- 
  read_xlsx("Data_2020/Paro_por_municipios_2020.xlsx", skip = 1) |> 
  select("Codigo Municipio", "total Paro Registrado", "Paro Servicios", "Paro Construcción","Paro Industria", "Paro Agricultura", "Paro Sin empleo Anterior") |> 
  rename(INE = "Codigo Municipio",
         Paro_total = "total Paro Registrado",
         Paro_servicio = "Paro Servicios",
         Paro_constr = "Paro Construcción",
         Paro_indu = "Paro Industria",
         Paro_agri = "Paro Agricultura",
         Paro_sin_emp = "Paro Sin empleo Anterior") |> 
  mutate(INE = ifelse(nchar(INE) == 4, paste0("0", INE), INE)) |> # 2.5 because in between 0 and 5
  mutate(Paro_total = ifelse(Paro_total == "<5", 2.5, as.numeric(Paro_total)),
         share_ue_service = ifelse(Paro_total == 0, 0,(Paro_servicio/Paro_total)*100),
         share_ue_construction = ifelse(Paro_total == 0, 0,(Paro_constr/Paro_total)*100),
         share_ue_industry = ifelse(Paro_total == 0, 0,(Paro_indu/Paro_total)*100),
         share_ue_agriculture = ifelse(Paro_total == 0, 0,(Paro_agri/Paro_total)*100),
         share_ue_wo_job = ifelse(Paro_total == 0, 0,(Paro_sin_emp/Paro_total)*100)) |> 
  select(-c(Paro_servicio, Paro_constr, Paro_indu, Paro_agri, Paro_sin_emp))
```

December data is added manually.

```{r, results='hide'}
folder_path <- "Data_2020/paro_diciembre_2020"

# Getting a list of csv files in the folder
excel_files <- list.files(folder_path, full.names = TRUE)

# Initializing an empty list to store data frames
all_data <- list()

# Looping through each csv file and read it into a data frame
for (i in seq_along(excel_files)) {
  file <- excel_files[i]
  
  data <- read_excel(file, skip = 6) |> 
  select("...1", "...3", "...10", "...11", "...12", "...13", "...14") |> 
  rename(INE = ...1,
         Paro_total = ...3,
         Paro_servicio = ...13,
         Paro_constr = ...12,
         Paro_indu = ...11,
         Paro_agri = ...10,
         Paro_sin_emp = ...14) |> 
  mutate(INE = as.character(INE),
         INE = if_else(nchar(INE) == 4, paste0("0", INE), INE),
         Paro_total = ifelse(Paro_total == "<5", 2.5, as.numeric(Paro_total)),
         share_ue_service = ifelse(Paro_total == 0, 0,(Paro_servicio/Paro_total)*100),
         share_ue_construction = ifelse(Paro_total == 0, 0,(Paro_constr/Paro_total)*100),
         share_ue_industry = ifelse(Paro_total == 0, 0,(Paro_indu/Paro_total)*100),
         share_ue_agriculture = ifelse(Paro_total == 0, 0,(Paro_agri/Paro_total)*100),
         share_ue_wo_job = ifelse(Paro_total == 0, 0,(Paro_sin_emp/Paro_total)*100)) |> 
  drop_na() |> 
  select(-c(Paro_servicio, Paro_constr, Paro_indu, Paro_agri, Paro_sin_emp))
  
  # Append the data frame to the list
  all_data[[length(all_data) + 1]] <- data
}

unemployment_2020_dec <- do.call(rbind, all_data)

# rbind to unemployment data
unemployment_2020 <- rbind(unemployment_2020, unemployment_2020_dec)



```

Social security data is loaded into the environment.

```{r, results='hide'}
# Setting the directory path where csv files are located
folder_path <- "Data_2020/SS_2020"

# Getting a list of csv files in the folder
excel_files <- list.files(folder_path, full.names = TRUE)

# Initializing an empty list to store data frames
all_data <- list()

# Looping through each csv file and read it into a data frame
for (file in excel_files) {

  data <- read_excel(file, skip = 1)
  
  # Append the data frame to the list
  all_data[[length(all_data) + 1]] <- data
}

# column name mistakes rendered this step necessary --> selecting columns for every data frame in the list
for (i in seq_along(all_data)) {
  all_data[[i]] <- all_data[[i]][, c("TOTAL", "MUNICIPIO")]
}

# Combine all data frames into a single object
social_security_2020 <- bind_rows(all_data)
```

Per municipality, the average number of people in social security noted employment.

```{r}
social_security_2020 <- 
  social_security_2020 |> 
  mutate(MUNICIPIO = str_replace(MUNICIPIO, "^(\\S+) ", "\\1_")) |> 
  separate(MUNICIPIO, into = c("INE", "NOMBRE"), sep = "_") |> 
  mutate(TOTAL_SS = gsub("\\.", "", TOTAL)) |> # deleting dots
  mutate(TOTAL_SS = as.numeric(str_extract(TOTAL_SS, "\\d+"))) |>  # extracting only the numbers
  select(INE, NOMBRE, TOTAL_SS) |> 
  drop_na(TOTAL_SS) |> 
  group_by(INE) |> 
  summarise(mean_ss = mean(TOTAL_SS, rm.na = T)) |> 
  ungroup()
```

Averages for (shares of) unemployment is calculated. Following social security information is joined, and the unemployment rate is calculated.

```{r}
unemployment_rate_2020 <- 
  unemployment_2020 |> 
  group_by(INE) |> 
  summarise(mean_ue = mean(Paro_total),
            share_ue_service = mean(share_ue_service),
            share_ue_construction = mean(share_ue_construction),
            share_ue_industry = mean(share_ue_industry),
            share_ue_agriculture = mean(share_ue_agriculture),
            share_ue_wo_job = mean(share_ue_wo_job)) |> 
  ungroup() |> 
  left_join(social_security_2020, by = "INE") |> 
  select(INE, mean_ue, mean_ss, share_ue_service, share_ue_construction, share_ue_industry, share_ue_agriculture, share_ue_wo_job) |> 
  mutate(ue_pct_2020 = (mean_ue/(mean_ue + mean_ss))*100) |> 
  drop_na(ue_pct_2020)
```

```{r}
unemployment_rate_2020 <- 
  unemployment_rate_2020 |>
  select(INE, ue_pct_2020, share_ue_service, share_ue_construction, share_ue_industry, share_ue_agriculture, share_ue_wo_job)
```

## DEA Target II - Income

Median income per consumption unit is recoverd from INE.

```{r, results='hide'}
median_income <- 
  read_excel("Data_2020/income_2021.xlsx", skip = 7) |> 
  select(...1, "2021...23") |> 
  rename(municipio = ...1,
         median_inc_con_unit = "2021...23") |> 
  mutate(municipio = str_replace(municipio, "^(\\S+) ", "\\1_")) |> 
  separate(municipio, into = c("INE", "NOMBRE"), sep = "_") |> 
  filter(nchar(INE) == 5) |> 
  mutate(median_inc_con_unit = as.numeric(median_inc_con_unit)) |> 
  select(-NOMBRE)
```

## Covid - employment data

Municipal information on the share of business and the share of unemployment declared as essential are recovered from [INE](https://www.ine.es/jaxi/Tabla.htm?path=/COVID/dirce/l0/&file=01002.px&L=0).

```{r}
covid_employment <- 
  read_excel("Data_2020/essential_emp_mun_2020.xlsx", skip = 5) |> 
  mutate(...1 = str_replace(...1, "^(\\S+) ", "\\1 ")) |> 
  separate(...1, into = c("INE", "NOMBRE"), sep = "-") |> 
  rename(share_essential_business = "Porcentaje de empresas que prestan servicios esenciales",
         share_essential_employment = "Porcentaje de empleo respecto al total de la actividad") |> 
  mutate(share_essential_employment = as.numeric(share_essential_employment)) |> 
  select(INE, share_essential_business, share_essential_employment)
```

## Political leadership

### Municipality - Party of mayor

To recover the information on the party of the mayor of a given municipality during 2020, a if, else_if structure is required.

```{r}
political_leadership_mun <- 
  read_excel("Data_2020/Alcaldes_Mandato_2019_2023.xlsx", skip = 6) |> 
  rename(INE = "CÓDIGO INE",
         party_mun = LISTA,
         resignation_date = "FECHA BAJA") |> 
  mutate(INE = substr(INE, 1, nchar(INE) - 1)) |> 
  select(MUNICIPIO, INE, party_mun, "NOMBRE",resignation_date) |> 
  group_by(INE) |> 
  filter(if(all(is.na(resignation_date))) TRUE else if(any(!is.na(resignation_date) & resignation_date < as.Date("2020-01-01"))) row_number() == max(which(resignation_date < as.Date("2020-01-01"))) + 1 else row_number() == 1) |> # if resignation is NA then keep the row, else if the row is not NA and the resignation date is before 2022-01-01 it chooses the row number where the resignation date is closest below 2022-01-01 and selects the row +1. This effectively chooses the row of the mayor who assumed his position before 2022-01-01. If the resignation date is not before 2022-01-01 then the first row is chosen.
  select(INE, party_mun) |> 
  mutate(party_mun = party_mun)
```

### CCAA

Information on the governing party of the Autonomous Communities is recovered from [Wikipedia](https://es.wikipedia.org/wiki/Anexo:Presidencias_auton%C3%B3micas_espa%C3%B1olas) using the tribble function.

```{r}

code_CCAA <-
  tibble::tribble(
  ~Código,                      ~Literal,
     "01",                   "Andalucía",
     "02",                      "Aragón",
     "03",     "Asturias, Principado de",
     "04",              "Balears, Illes",
     "05",                    "Canarias",
     "06",                   "Cantabria",
     "07",             "Castilla y León",
     "08",        "Castilla - La Mancha",
     "09",                    "Cataluña",
     "10",        "Comunitat Valenciana",
     "11",                 "Extremadura",
     "12",                     "Galicia",
     "13",        "Madrid, Comunidad de",
     "14",           "Murcia, Región de",
     "15", "Navarra, Comunidad Foral de",
     "16",                  "País Vasco",
     "17",                   "Rioja, La",
     "18",                       "Ceuta",
     "19",                     "Melilla"
  )



political_leadership_CCAA <- 
  tibble::tribble(
   ~CCAA,                ~President,     ~Start,      ~End,  ~Duration,  ~Party,
  "Andalucía",            "Juan Manuel Moreno",      "18 de enero de 2019",              "en el cargo",   "5 años y 94 días",   "PP",
  "Aragón",                 "Javier Lambán",       "5 de enero de 2015",     "10 de agosto de 2023",  "8 años y 217 días", "PSOE",
  "Asturias, Principado de",             "Adrián Barbón",  "20 de julio de 2019",          "en el cargo",  "4 años y 276 días", "PSOE",
  "Balears, Illes", "Francina Armengol",   "2 de julio de 2015", "19 de junio de 2023", "7 años y 352 días", "PSOE",
  "Canarias", "Ángel Víctor Torres", "16 de julio de 2019",  "14 de julio de 2023", "3 años y 363 días", "PSOE",
  "Cantabria", "Miguel Ángel Revilla (2º)",   "7 de julio de 2015",  "5 de julio de 2023", "7 años y 363 días", "PRC",
  "Castilla - La Mancha", "Emiliano García-Page", "4 de julio de 2015", "en el cargo", "8 años y 292 días", "PSOE",
  "Castilla y León", "Alfonso Fernández Mañueco",  "12 de julio de 2019",          "en el cargo",   "4 años y 284 días", "PP",
  "Cataluña", "Joaquim Torra", "17 de mayo de 2018",               "28 de septiembre de 2020",  "2 años y 134 días",  "JxCat",
  "Ceuta", "Juan.Jesús.Vivas", "6.de.febrero.de.2001",         "en.el.cargo", "23.años.y.106.días",    "PP",
  "Comunitat.Valenciana",     "Ximo.Puig", "28.de.junio.de.2015", "13.de.julio.de.2023", "8.años.y.15.días", "PSOE",
  "Extremadura", "Guillermo Fernández Vara (2º)",  "7 de julio de 2015",  "14 de julio de 2023",    "8 años y 7 días", "PSOE",
  "Galicia", "Alfonso Rueda Valenzuela",   "14 de mayo de 2022",         "en el cargo",   "1 año y 343 días", "PP",
  "Rioja, La",         "Concha Andreu", "27 de agosto de 2019",   "30 de junio de 2023", "3 años y 307 días", "PSOE",
  "Madrid, Comunidad.de",  "Isabel.Díaz.Ayuso", "19.de.agosto.de.2019",         "en.el.cargo", "4.años.y.251.días",  "PP",
  "Melilla",	"Eduardo.de.Castro", "15.de.junio.de.2019",	"7.de.julio.de.2023",	"4.años.y.22.días", "Cs",
   "Murcia, Región de", "Fernando López Miras", "3 de mayo de 2017", "en el cargo", "6 años y 354 días", "PP",
  "Navarra, Comunidad Foral de", "María Chivite",  "6 de agosto de 2019",          "en el cargo", "4 años y 259 días", "PSOE",
  "País Vasco", "Iñigo Urkullu", "15 de diciembre de 2012",              "en el cargo", "11 años y 128 días", "PNV"
  )

political_leadership_CCAA <- 
  political_leadership_CCAA |> 
  mutate(across(c(CCAA, President, Start, End, Duration, Party), ~gsub("\\.", " ", .))) |> left_join(code_CCAA, by = c("CCAA" = "Literal")) |> 
  select(CCAA, Party, Código) |> 
  rename(party_ccaa = Party,
         CODAUTO = Código)
```

### Ideology

Ideology scores are recovered from the following data set: [here](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC10864869/). Values are noted in [PDF](https://zenodo.org/records/10066112).

```{r}
ideology <- 
  tribble(
  ~PARTY, ~ID_INDEX,
  "PSOE", 4.01,
  "ERC (Sólo en Cataluña)", 3.03,
  "UPN (Sólo en Navarra)", 8.22,
  "PP", 7.83,
  "Junts (Sólo en Cataluña)", 5.7,
  "CC (Sólo en Canarias)", 5.98,
  "VOX", 9.37,
  "PDeCAT", 5.5,
  "Nueva Canarias (Sólo en Canarias)", 5.25,
  "Podemos", 2.43,
  "En Comú Podem (Sólo en Cataluña)", 3.1,
  "BNG (Sólo en Galicia)", 2.73,
  "IU", 2.27,
  "CUP (Sólo en Cataluña)", 1.84,
  "Més Compromís (Sólo en Comunidad Valenciana)", 2.75,
  "Ciudadanos", 6.71,
  "EAJ-PNV (Sólo en País Vasco)", 6.42,
  "PRC (Sólo en Cantabria)", 5.17,
  "Más País", 3.02,
  "EH Bildu (Sólo en País Vasco y Navarra)", 2.31,
  "Teruel Existe (Sólo en provincia de Teruel)", 4.75,
  "Elkarrekin Podemos", 2.98,
  "PNC", 5.2
)

ideology <- 
  ideology |> 
  mutate(PARTY = str_replace(PARTY, "\\(.*", ""),
         PARTY = str_replace(PARTY, "EAJ-PNV", "PNV"),
         PARTY = str_replace(PARTY, "Ciudadanos", "Cs"),
         PARTY = str_replace(PARTY, "Junts", "JxCat"),
         PARTY = str_replace(PARTY, "EH Bildu", "BILDU"),
         PARTY = str_replace(PARTY, "Podemos", "PODEMOS"),
         PARTY = trimws(PARTY))
  
```

Ideology data is joined with municipal and Autonomous Community data.

```{r}
political_leadership_CCAA <- 
  political_leadership_CCAA |> 
  left_join(ideology, by = c("party_ccaa"= "PARTY")) |> 
  mutate(party_ccaa_id = ID_INDEX) |> 
  select(CCAA, CODAUTO, party_ccaa, party_ccaa_id)
```

```{r}
political_leadership_mun <- 
  political_leadership_mun |>
  mutate(party_mun = str_replace(party_mun, "\\(.*", ""),
         party_mun = str_replace(party_mun, "EAJ-PNV", "PNV"),
         party_mun = str_replace(party_mun, "C´s", "Cs"),
         party_mun = str_replace(party_mun, "CCa-PNC", "CC")) |> 
  left_join(ideology, by = c("party_mun" = "PARTY")) |>
  mutate(party_mun_id = ID_INDEX) |> 
  select(INE, party_mun, party_mun_id)
```

## Tax codes

Taxation levied by municipalities is recovered from [here](https://serviciostelematicosext.hacienda.gob.es/SGFAL/ConsultaTipos/aspx/listado_municipiosm.aspx).

```{r}
tax_rates_2020 <- 
  read_excel("Data_2020/mun_tax_2020.xlsx", skip = 2) |> 
  rename(INE = "CCAA-Prov-Ayto",
         urban_prop_tax = "Urbana",
         rural_prop_tax = "Rústica",
         special_prop_tax = "Caract. Esp.",
         cons_work_tax = "Tipo Gravamen",
         max_coef_turn_tax = "Coef situación max",
         min_coef_turn_tax = "Coef situación min") |> 
  mutate(INE = str_replace_all(INE, "(\\d{2})-(\\d{2})-(\\d{3})", "\\2\\3")) |> 
  select(INE, urban_prop_tax, rural_prop_tax, special_prop_tax, max_coef_turn_tax, min_coef_turn_tax)
```

## List of useful data-frames

To reduce the number of objects in the environment, only objects subsequently used to create the final data frame are kept.

```{r}
objects <- ls()
object_to_keep <- c("df_spen_imp_mun_tidy",
                    "diff_ue",
                    "unemployment_rate_2020",
                    "population", 
                    "n_firms", 
                    "dist_cap",
                    "avg_age_final",
                    "contracts",
                    "political_leadership_CCAA",
                    "political_leadership_mun",
                    "spending_CCAA_final",
                    "median_income",
                    "tax_rates_2020",
                    "revenue_municipality_final",
                    "covid_employment",
                    "share_women")
objects_to_remove <- setdiff(objects, object_to_keep)
rm(list = objects_to_remove)
```

## Merging tables

```{r}
df <- 
  df_spen_imp_mun_tidy |> 
  left_join(dist_cap, by =  "INE") |> 
  left_join(unemployment_rate_2020, by = "INE") |> 
  left_join(diff_ue, by = "INE") |> 
  left_join(population, by = "INE") |> 
  left_join(share_women, by = "INE") |> 
  left_join(covid_employment, by = "INE") |> 
  left_join(n_firms, by = "INE") |> 
  left_join(avg_age_final, by = "INE") |> 
  left_join(contracts, by = "INE") |> 
  left_join(political_leadership_mun, by = "INE") |> 
  left_join(median_income, by = "INE") |> 
  left_join(tax_rates_2020, by = "INE") |> 
  left_join(revenue_municipality_final, by = "INE") |> 
  left_join(political_leadership_CCAA, by = "CODAUTO") |> 
  left_join(spending_CCAA_final, by = "CODAUTO") 
```

## Creating variables

### Per capita values

Per capita variables are created and original variables are dropped.

```{r}
df <- 
  df |>
  mutate(per_capita_MUN = total_MUN/pop_total,
         pop_density = pop_total/ area_sqkm,
         per_capita_contracts = contracts_mean_2020/pop_total,
         per_capita_n_firms = n_firms/pop_total) |> 
  select(-c(contracts_mean_2020, total_CCAA, total_MUN))
```

### Ideology score

The ideology score - mean of ideology of governing parties on the municipal and Autonomous Community level is calculated.

```{r}
df <- 
  df |> 
  mutate(ideology_score = (party_ccaa_id + party_mun_id) / 2)
```

Missing ideology score will be imputed (around 1000 NAs)

### Renaming fields of expenditure

```{r}
df <- 
  df |> 
  rename(employment_promotion = "Fomento del Empleo",
         general_services = "Servicios de carácter general",
         pub_safety_mobility = "Seguridad y movilidad ciudadana",
         housing_urban_plan = "Vivienda y urbanismo",
         community_wellbeing = "Bienestar comunitario",
         environment = "Medio ambiente",
         culture = "Cultura",
         tax_fin_admin = "Administración financiera y tributaria",
         public_debt = "Deuda Pública",
         health = "Sanidad",
         education = "Educación",
         infrastructure = "Infraestructuras",
         employee_benefits = "Otras prestaciones económicas a favor de empleados",
         social_services = "Servicios Sociales y promoción social",
         business_turism_sme = "Comercio, turismo y pequeñas y medianas empresas",
         gov_bodies = "Órganos de gobierno",
         sports = "Deporte",
         industry_eng = "Industria y energía",
         pub_transportation = "Transporte público",
         r_and_d = "Investigación, desarrollo e innovación",
         trans_public_agencies = "Transferencias a otras Administraciones Públicas",
         agr_farm_fish = "Agricultura, Ganadería y Pesca",
         pensions = "Pensiones",
         other_econ = "Otras actuaciones de carácter económico") 
```

### Deleting Ceuta and Melilla

```{r}
df <- 
  df |> 
  filter(!NOMBRE == "Ceuta" & !NOMBRE == "Melilla")
```

### Filtering out NA values for target values

```{r}
df_final <- 
  df |> 
  filter(!is.na(diff_ue)) |> 
  filter(!is.na(median_inc_con_unit))
```

## Saving data frame

```{r}
write.csv(df_final, paste("Data_2020/TFM_data_", Sys.Date(), ".csv", sep = ""))
```
